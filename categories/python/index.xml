<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Python - Category - Evilmass</title><link>https://evilmass.github.io/categories/python/</link><description>Python - Category - Evilmass</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 08 Feb 2023 14:55:48 +0800</lastBuildDate><atom:link href="https://evilmass.github.io/categories/python/" rel="self" type="application/rss+xml"/><item><title>CopyImageToClipboard</title><link>https://evilmass.github.io/posts/copyimagetoclipboard/</link><pubDate>Wed, 08 Feb 2023 14:55:48 +0800</pubDate><author>Author</author><guid>https://evilmass.github.io/posts/copyimagetoclipboard/</guid><description>Win10 下复制图片发送到 QQ 群总是变成文件，每次要打开图片-复制-关闭图片也很繁琐。
市面上现有的工具不多：
xclip，仅限 Linux 平台使用。 CopyContents，免费试用 15 天，每次右键复制图片内容都提示一次，还有个巨复古的浮框。 Talk Is Cheap 保存为 pyw 文件用 pythonw.exe 执行避免出现一闪而过的黑框。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # coding:utf-8 import sys import traceback import win32clipboard from io import BytesIO from PIL import Image def send_to_clipboard(clip_type, data): win32clipboard.OpenClipboard() win32clipboard.</description></item><item><title>python import</title><link>https://evilmass.github.io/posts/python_import/</link><pubDate>Sun, 21 Feb 2021 18:31:38 +0800</pubDate><author>Author</author><guid>https://evilmass.github.io/posts/python_import/</guid><description>目录结构 C:\USERS\EVILMASS\DESKTOP\PATH0 │ server.py ├───path1 │ │ func.py │ │ __init__.py └───path2 │ func.py │ __init__.py ├───path2_1 │ │ func.py │ │ __init__.py │ ├───path2_1_1 │ │ │ func.py │ │ │ special.py │ │ │ __init__.py __init__.py 一个 module1.py 文件可以看作一个模块：import module1
__init__.py 则是将一个文件夹变为 package
每一次 import 都会执行 __init__.py 内的代码。
1 2 3 4 5 6 7 8 # no __init__.py from path2.path2_1.func import echo from path2.path2_1.special import echo_special # has __init__.</description></item><item><title>Python 多线程笔记</title><link>https://evilmass.github.io/posts/multithreading/</link><pubDate>Thu, 11 Feb 2021 01:17:31 +0800</pubDate><author>Author</author><guid>https://evilmass.github.io/posts/multithreading/</guid><description><![CDATA[中国有句古话：好记性不如烂笔头。看会了和学会了是两码事，能教会别人说明是真掌握了。
比起一堆 job1 | job2 和 生产者-消费者 模型，单纯复制粘贴相似度 99% 的代码就算自己敲一遍也不会有印象。
反向思考 请写出一个死锁的案例 加锁即为互斥，防止多线程同时修改同一个资源导致数据错误。
A 拿酱油 -&gt; 酱油炒饭耗时10分钟 -&gt; 拿盐 # 等待B放回盐 -&gt; 盐水菜心耗时5分钟 -&gt; 放回盐 -&gt; 放回酱油 B 拿盐 -&gt; 盐水菜心耗时5分钟 -&gt; 拿酱油 # 等待A放回酱油 -&gt; 酱油炒饭耗时10分钟 -&gt; 放回酱油 -&gt; 放回盐 你在等酱油我在盐，两人的下一道菜就永远卡这了。
当然这种写法肯定是有问题的，资源执行和释放的顺序不一致。
解决方法 让步：
只要每个线程执行完任务立马释放相应资源，线程崩溃的话设置好超时释放。 排队：
同时竞争资源，用队列（推荐）解决。 规则：
占用资源前给予规则限制。 例子：5人吃饭同时拿起左边筷子并等待右边筷子的释放。 解决：给筷子编号，没拿到小号筷子前不能拿大号的。最大数字的筷子不可能单独拿到，问题解决。 如果用多进程处理多线程代码，会发生什么 问的其实是二者在使用方面的区别，首先自然是确定多线程代码执行的任务是什么。
如果要处理 `IO密集型`任务，用多进程反而会慢，主要耗时在创建和维护进程过程。 如果处理 `CPU密集型`任务，则可以充分利用多核优势并行计算。 多进程的主要问题：
进程不共享内存，计算的输入必须被传到每个工作进程里，比如列表中的元素； 能被传递的东西必须 picklable，而有相当多的东西是 unpicklable 的； 如果后续程序执行需要并行计算的输出，那么这些输出也得 picklable； Pickle -&gt; unpickle 操作带来了额外的性能开销。 多线程涉及资源竞争&amp;修改、死锁、上下文切换导致效率下降问题。]]></description></item></channel></rss>