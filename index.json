[{"categories":["树莓派"],"content":"今晚登录树莓派发现输入延迟很高，htop 打开一看 clash 占用的内存快拉满了，netstat -anp 发现有很多不明连接。 搜到相关 Issue：请考虑关闭 Allow-Lan，还是那句：任何需要部署到公网的东西都要注意权限（身份验证+端口限制）最小化。 allow-lan: true authentication: - \"\u003cuser\u003e:\u003cpass\u003e\" external-controller: '127.0.0.1:9090' secret: '\u003csecret\u003e' 还好在树莓派上跑的是备用代理 CloudFlare WARP，要是机场梯子的话 200G 流量一下午就能刷完。 添加相应配置之后就没有不明 IP 连进来了。 ","date":"2023-07-28","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE-clash-%E9%81%AD%E9%81%87%E5%A4%A7%E9%87%8F%E4%B8%8D%E6%98%8E-http-connections/:0:0","tags":["clash","树莓派"],"title":"树莓派 clash 遭遇大量不明 http connections","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE-clash-%E9%81%AD%E9%81%87%E5%A4%A7%E9%87%8F%E4%B8%8D%E6%98%8E-http-connections/"},{"categories":["杂"],"content":"微信是我见过最傻逼的产品。 文章标题已经把整个流程描述完了，如果有便签请顺手记录下微信号和绑定银行卡的后六位，说不定哪天就用上。 即便如此，四个验证步骤（找回密码的短信验证 -\u003e 是否记得微信号 -\u003e 人脸识别 -\u003e 确认短信）有一个填错直接重来，微信依然是我见过最傻逼的产品。 ","date":"2023-07-27","objectID":"/posts/%E9%80%9A%E8%BF%87%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81%E8%A7%84%E9%81%BF%E5%BE%AE%E4%BF%A1%E5%9C%A8%E6%96%B0%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E7%9A%84%E5%A5%BD%E5%8F%8B%E9%AA%8C%E8%AF%81/:0:0","tags":["微信\""],"title":"通过找回密码绕过微信在新设备登录的好友验证","uri":"/posts/%E9%80%9A%E8%BF%87%E6%89%BE%E5%9B%9E%E5%AF%86%E7%A0%81%E8%A7%84%E9%81%BF%E5%BE%AE%E4%BF%A1%E5%9C%A8%E6%96%B0%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E7%9A%84%E5%A5%BD%E5%8F%8B%E9%AA%8C%E8%AF%81/"},{"categories":[],"content":"继 Heroku、Railway 收费后，能免费使用（好用）的网站托管服务还剩下 Vercel和 Huggingface。 但 Vercel 不支持 docker deployment，huggingface 限制则很少。 unlimited！ 确实良心。 ","date":"2023-07-27","objectID":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/:0:0","tags":["huggingface"],"title":"huggingface 部署 docker 记录","uri":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/"},{"categories":[],"content":"配置文件 官方文档其实很清晰了，这里简单贴一下没有读写权限问题的 FastAPI Server 配置。 ","date":"2023-07-27","objectID":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/:1:0","tags":["huggingface"],"title":"huggingface 部署 docker 记录","uri":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/"},{"categories":[],"content":"README.md --- title: Sig emoji: 🐢 colorFrom: green colorTo: pink sdk: docker app_port: 7860 pinned: false --- Check out the configuration reference at https://huggingface.co/docs/hub/spaces-config-reference ","date":"2023-07-27","objectID":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/:1:1","tags":["huggingface"],"title":"huggingface 部署 docker 记录","uri":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/"},{"categories":[],"content":"Dockerfile 利用多级构建缓存减少后续部署时间。 # build cache FROM python:3.9-slim-bullseye as builder WORKDIR /tmp # depends RUN apt-get update -y COPY ./requirements.txt /tmp/requirements.txt RUN pip install -r /tmp/requirements.txt # playwright RUN playwright install-deps # Set up a new user named \"user\" with user ID 1000 RUN useradd -m -u 1000 user # Switch to the \"user\" user USER user # Set home to the user's home directory ENV HOME=/home/user \\ PATH=/home/user/.local/bin:$PATH # Set the working directory to the user's home directory WORKDIR $HOME/app # create folder RUN mkdir $HOME/app/cookie $HOME/app/log $HOME/app/_playwright $HOME/app/config # Try and run pip command after setting the user with `USER user` to avoid permission issues with Python RUN playwright install chromium firefox # use build cache FROM builder # Copy the current directory contents into the container at $HOME/app setting the owner to the user COPY --chown=user . $HOME/app CMD [\"uvicorn\", \"app:app\", \"--host\", \"0.0.0.0\", \"--port\", \"7860\"] ","date":"2023-07-27","objectID":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/:1:2","tags":["huggingface"],"title":"huggingface 部署 docker 记录","uri":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/"},{"categories":[],"content":"app.py 必须要有 app.py 才能运行服务。 # coding: utf-8 from fastapi import FastAPI from fastapi.responses import Response app = FastAPI() @app.get(\"/\") def home(): html_content = open(\"index.html\").read() return Response(content=html_content, status_code=200) ","date":"2023-07-27","objectID":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/:2:0","tags":["huggingface"],"title":"huggingface 部署 docker 记录","uri":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/"},{"categories":[],"content":"外网连通性 当使用私有域名进行数据交互的时候，无法从容器内发送请求到外部，而本地不同网络下测试是正常的。 可能是 bug。 # 成功 requests.get(\"https://checkip.amazonaws.com\").text.strip() # 失败 requests.get(\"https://\u003cyour_domain\u003e/v1/request\").text.strip() 目前只能通过 IP:PORT 的方式处理数据。 ","date":"2023-07-27","objectID":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/:3:0","tags":["huggingface"],"title":"huggingface 部署 docker 记录","uri":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/"},{"categories":[],"content":"Secret 如果要在部署环境使用敏感信息，可以在环境变量添加 ACCESS_TOKEN 后在 [[huggingface 部署 docker 环境#Dockerfile]] 加入下面的内容： RUN --mount=type=secret,id=ACCESS_TOKEN,mode=0444,required=true \\ curl test -H 'Authorization: Bearer $(cat /run/secrets/ACCESS_TOKEN)' 如果更改 Secret 变量名，记得删掉原来重名的变量（系统变量调用顺序自上而下）。 ","date":"2023-07-27","objectID":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/:4:0","tags":["huggingface"],"title":"huggingface 部署 docker 记录","uri":"/posts/huggingface-%E9%83%A8%E7%BD%B2-docker-%E7%8E%AF%E5%A2%83/"},{"categories":["工具"],"content":"选型 目前在 huggingface 部署了多个签到脚本，由于仓库设置成 Private，想看脚本输出就只能在浏览器请求 log/filename=\u003cfilename\u003e\u0026token=\u003ctoken\u003e 接口。 及时获取签到通知就成了一个新需求，要求如下： 能自建推送服务器。 这部分隐私要求可有可无，单纯是数据在自己手上比较安心。签到日志输出内容： \u003cdatetime.now\u003e \u003csign_platform\u003e \u003csign_result\u003e，没有任何利用价值。 足够简单。 这个则是针对安卓端的需求，安卓推送需要 FCM（绑定谷歌三件套）必须在后台一直挂着梯子，所以 App 方案反而是能接受的。 那可选的也就不多了，首先排除：WxPusher、Server酱、TelegramBot、QQBot、邮箱。 那就只剩下 pushdeer、Bark、Gotify。 ","date":"2023-07-25","objectID":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/:1:0","tags":["gotify"],"title":"使用 Gotify 推送签到消息","uri":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/"},{"categories":["工具"],"content":"pushdeer 最开始吸引我的是 pushdeer，下载 App 打开后发现 UI 做的还可以。 But emmm，登录进去发现安卓端还没有开发好自建服务器的功能，推送信息下面还带广告，直接弃用。 ","date":"2023-07-25","objectID":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/:2:0","tags":["gotify"],"title":"使用 Gotify 推送签到消息","uri":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/"},{"categories":["工具"],"content":"Bark 针对 Apple 设备推送的效果很好，但是官方没有提供安卓端的 App，目前只有 PushLite 可用，要一直挂着梯子，且 PushLite 界面过于简陋，弃用。 ","date":"2023-07-25","objectID":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/:3:0","tags":["gotify"],"title":"使用 Gotify 推送签到消息","uri":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/"},{"categories":["工具"],"content":"Gotify 官方文档清晰明了，无论是搭建服务端还是使用客户端接收消息都突出一个简单易用还好用。 do one thing，and do well. ","date":"2023-07-25","objectID":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/:4:0","tags":["gotify"],"title":"使用 Gotify 推送签到消息","uri":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/"},{"categories":["工具"],"content":"服务端 树莓派使用可执行文件 + Nginx 做反向代理。 # \u003e curl -s https://api.github.com/repos/gotify/server/releases/latest | grep \"browser_download_url\" | grep arm64 | cut -d '\"' -f 4 # \u003e https://github.com/gotify/server/releases/download/v2.3.0/gotify-linux-arm64.zip # 获取最新版本的下载链接，wget -i 表示指定 url 来源，- 表示url来源为 stdin。 mkdir gotify-server cd gotify-server curl -s https://api.github.com/repos/gotify/server/releases/latest | grep \"browser_download_url\" | grep arm64 | cut -d '\"' -f 4 | wget -i - # 解压 unzip gotify*.zip # 给予可执行权限 chmod +x gotify* # 获取运行配置文件 wget -O config.yml https://raw.githubusercontent.com/gotify/server/master/config.example.yml # 修改相应端口为 38000 sed -i s'/80/38000' -i config.yml # 运行 sudo ./gotify* 如果是国内服务器或家庭宽带有公网 IP（封锁 80/443 端口） + 未备案域名，可以先用 dns challenge 绕过获得 gotify.\u003cyour_domain\u003e SSL 证书，然后再使用 aliddns 定时自动更新 IP 并解析到域名上。 # nginx 服务器配置 server { listen [::]:80; listen [::]:443 ssl http2; server_name \u003cyour_domain\u003e; # 解析的域名，自定义替换 if ($server_port !~ 443){ rewrite ^(/.*)$ https://$host$1 permanent; } #SSL配置 # RSA Cert ssl_certificate /etc/letsencrypt/live/\u003cyour_domain\u003e/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/\u003cyour_domain\u003e/privkey.pem; ssl_stapling on; ssl_stapling_verify on; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20 -POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384::!MD5; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_session_tickets off; # add_header Strict-Transport-Security \"max-age=31536000\" always; # HSTS 设置，按需启用 error_page 497 https://$host$request_uri; # . files location ~ /\\.(?!well-known) { deny all; } # robots.txt location = /robots.txt { default_type text/html; add_header Content-Type \"text/plain; charset=UTF-8\"; return 200 \"User-Agent: *\\nDisallow: /\"; } # 如果要使用自定义后缀就改 location 的 / 为 /\u003cpath\u003e location / { proxy_pass http://localhost:38000; proxy_http_version 1.1; # Ensuring it can use websockets proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto http; proxy_redirect http:// $scheme://; # The proxy must preserve the host because gotify verifies the host with the origin # for WebSocket connections proxy_set_header Host $http_host; proxy_connect_timeout 7m; proxy_send_timeout 7m; proxy_read_timeout 7m; } } 重启 nginx 服务器之后就能在 http://localhost:38000 看到 Gotify 的网页版了。 第一次进去要重置 admin 密码，然后按需求创建不同的应用来分类，Gotify 会根据不同应用的 Token 来推送消息。 测试推送 import requests \"\"\" extras 的 bigImageUrl 参数只能使用直链图片 url， sm.ms 图床的图片 url 会跳转一次导致无法正常显示。 \"\"\" # gotify 推送 def push_msg(title: str = \"无标题\", message: str = \"无内容\", img_url: str = gotify_img): url = f\"https://{gotify_domain}/message?token={gotify_token}\" resp = requests.post( url=url, json={ \"title\": title, \"message\": message, \"priority\": 10, \"extras\": { \"client::display\": {\"contentType\": \"text/markdown\"}, \"client::notification\": {\"bigImageUrl\": img_url} } } ) return resp.json() 成功接收消息。 ","date":"2023-07-25","objectID":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/:4:1","tags":["gotify"],"title":"使用 Gotify 推送签到消息","uri":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/"},{"categories":["工具"],"content":"客户端 2.7.0 版本加入了自动重连的功能，原因是安卓系统默认针对在后台运行的 App 执行电池优化，所以还是建议手动加到白名单。即便如此 Gotify 实际使用下来一天也只耗 2% 的电，几乎忽略不计。 已经多久没见过只有 5m 的 App 了。 填入你的推送域名和登录信息即可。 带图片的推送。 ","date":"2023-07-25","objectID":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/:4:2","tags":["gotify"],"title":"使用 Gotify 推送签到消息","uri":"/posts/%E4%BD%BF%E7%94%A8-gotify-%E6%8E%A8%E9%80%81%E7%AD%BE%E5%88%B0%E6%B6%88%E6%81%AF/"},{"categories":["playwright"],"content":"browser 一行命令完成安装依赖和浏览器。 playwright install --with-deps chromium firefox ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:1:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"万能的 record 模式 参考 [[playwright 五分钟上手指南]]，遇到任何定位问题直接哪里不会点哪里。 await page.pause() ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:2:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"官方文档不推荐的写法 参考 Auto-waiting，绝大部分方法都会自动等待页面加载完成才执行相应操作，超过系统默认超时时间（30s）才会报错。 # https://playwright.dev/python/docs/api/class-page#page-wait-for-timeout await page.wait_for_timeout(1000) # DISCOURAGED await page.wait_for_load_state(\"networkidle\") # 等待网络加载完成 XPath locator和 CSS locator 也是不推荐的，更直观的写法是使用 Locator 的各种定位 API。 要等待某个元素出现选 is_enabled() | focus() 优于 is_visible()。 is_visible() 在 headless = False 下没有问题，但调试的下切换到其他窗口，is_visible() 就会失去聚焦对象。 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:3:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"多线程 文档确说明 Playwright’s API is not thread-safe，issue/623也有人给出多线程的实现，但还是推荐使用 async 完成。 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:4:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"多进程 同上，与其手动处理进程资源（开销），不如直接 async。 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:5:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"多 context \u0026 多 page 文档推荐的写法：Multiple Contexts in a Single Test，通过示例可以看出 playwright 自上而下的资源创建过程： 创建全局 browser 浏览器对象， 创建一个或多个 context 对象； 每个 context 又可以创建一个或多个 page对象。 可以理解为在一个任务里面只有一个谷歌浏览器（browser），可以拥有多个谷歌账号（context）， 每个账号（local storage）可以存储所有标签页（page） 的 cookie 信息。 Each browser context can host multiple pages (tabs) 也就是说： 只有一个 page 对象在遇到耗时任务时一定会持续等待当前任务完成，async/await 无法发挥作用，和串行完成任务没区别。 也就是说： 一个 context 下启动多个 page 也是近乎串行完成任务。而且启动多个 page 会占用资源，其他 page 一直在等上一个 page 完成任务才能开始工作。 也就是说： 真正意义上的异步同时完成任务就得分别创建多个 browser 对象。 可以简单测试单个 page 和 多个 page 的区别。先启动一个 fastapi 服务器，设置两个耗时任务。 import time from fastapi import FastAPI from uvicorn import run app = FastAPI() # 一！ @app.get(\"/sleep_one_second\") async def sleep_one_second(): time.sleep(1) return {\"res\": 1} # 五！ @app.get(\"/sleep_five_second\") async def sleep_five_second(): time.sleep(5) return {\"res\": 5} if __name__ == \"__main__\": run(\"server:app\", host=\"0.0.0.0\", port=8000, reload=True 测试 single/multi page 的执行时间。 import asyncio import time from functools import wraps from playwright.async_api import async_playwright def timeit(func): @wraps(func) async def wrapper(*args, **kwargs): s_time = time.perf_counter() await func(*args, **kwargs) print(f\"{func.__name__} cost {time.perf_counter() - s_time}s\") return loop.create_task(wrapper()) async def single_page(playwright): chromium = playwright.chromium browser = await chromium.launch(headless=False) context = await browser.new_context() page = await context.new_page() await page.goto(\"http://localhost:8000/sleep_one_second\") await page.goto(\"http://localhost:8000/sleep_five_second\") await browser.close() async def multi_page(playwright): chromium = playwright.chromium browser = await chromium.launch(headless=False) context = await browser.new_context() page1 = await context.new_page() page5 = await context.new_page() await page1.goto(\"http://localhost:8000/sleep_one_second\") await page5.goto(\"http://localhost:8000/sleep_five_second\") await browser.close() @timeit async def main(): async with async_playwright() as playwright: await single_page(playwright) # await multi_page(playwright) if __name__ == \"__main__\": loop = asyncio.get_event_loop() try: loop.run_forever() except (KeyboardInterrupt, SystemExit): exit() 分别注释执行你会发现两个任务都是 8秒4（创建浏览器+执行任务+关闭浏览器） 左右完成，和上面分析一样。 一个浏览器环境下并不会影响执行时间，创建多个 page 只是便于区分任务。 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:6:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"多开 如果还是不死心，一定要双开多开，以下写法也是可行的。 import asyncio import time from playwright.async_api import async_playwright async def init_page(playwright): browser = await playwright.chromium.launch(headless=False) context = await browser.new_context() page = await context.new_page() return page async def sleep_one_second(playwright): page = await init_page(playwright) await page.goto(\"http://localhost:8000/sleep_one_second\") await page.close() async def sleep_five_second(playwright): page = await init_page(playwright) await page.goto(\"http://localhost:8000/sleep_five_second\") await page.close() async def main(): async with async_playwright() as playwright: task1 = asyncio.create_task(sleep_one_second(playwright)) task2 = asyncio.create_task(sleep_five_second(playwright)) tasks = [task1, task2] await asyncio.gather(*tasks) if __name__ == \"__main__\": s_time = time.perf_counter() asyncio.run(main()) print(f\"cost {time.perf_counter() - s_time}s\") 因为创建了两个浏览器对象，耗时多了一秒。 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:7:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"报错：playwright._impl._api_types.Error: Playwright connection closed 多半是过度封装创建函数导致的。page 对象一旦跳出 async with async_playwright() as playwright: 上下文就无法获取 browser | context 远来的属性。 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:8:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"代理 async with async_playwright() as playwright: # 对整个 browser 设置代理 browser = await playwright.firefox.launch(headless=browser_headless, proxy=browser_proxy) context = await browser.new_context() # 对不同 context 设置代理 browser = await playwright.firefox.launch(headless=False) context = await browser.new_context(proxy=browser_proxy) ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:9:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"v2ex 点击签到按钮提示：你的浏览器有一些奇奇怪怪的设置，请用一个干净安装的浏览器重试一下吧。 原因：首页 referer 与其他页不匹配。 解决办法：得先回首页再跳转到签到页面。 await goto(home_url) await goto(sign_url) ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:10:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"b站直播间 使用 chromium 提示浏览器版本过低，firefox 则没问题。 同时提示：Cannot read properites of null (reading ‘sendDanmaku’) ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:11:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"鼠标悬停 hover或focus。 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:12:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"模拟正常输入 type('123', delay=1000) # 每个字的输入间隔为一秒 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:13:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"多个匹配元素报错 strict mode violation: get_by_placeholder(\"发个弹幕呗~\") resolved to 2 elements 直接 await page.pause() 开启调试模式找出是第几顺位的元素，根据情况使用：first、last、nth()。 # exact=True 精准匹配 print(await page.get_by_text(\"发个弹幕呗\").count()) await page.get_by_placeholder(\"发个弹幕呗~\").nth(1).fill(\"2\") await page.get_by_text(\"发送\", exact=True).nth(1).click(): ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:14:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"确认 ","date":"2023-07-23","objectID":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/:15:0","tags":["playwright"],"title":"Playwright 编写签到脚本遇到的问题","uri":"/posts/playwright-%E7%BC%96%E5%86%99%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["playwright"],"content":"本文旨在“快速上手”，所以不会像其他文章一样详细介绍每一个模块，具体用法请根据实际需求翻阅官方文档。 ","date":"2023-07-23","objectID":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:0:0","tags":["playwright"],"title":"playwright 快速上手指南","uri":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["playwright"],"content":"安装 pip3 install playwright playwright install chromium firefox ","date":"2023-07-23","objectID":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:1:0","tags":["playwright"],"title":"playwright 快速上手指南","uri":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["playwright"],"content":"调试模式 \u0026 生成代码 自动生成代码： playwright codegen -o test.py -b chromium 调试模式会自动记录并生成代码。 移动到相应位置显示元素定位代码，填入相关验证信息，点击登录。 右边的调试窗口已经自动生成刚才的登录流程代码（同步）了，将操作部分的代码加 await 改成异步即可。 import asyncio from playwright.async_api import async_playwright async def main(): \"\"\" headless = False，显示界面 slow_mo，模仿用户在一秒内完成每一步操作 \"\"\" async with async_playwright() as p: # 初始化浏览器 browser = await p.chromium.launch(headless=False, slow_mo=1000) context = await browser.new_context() page = await context.new_page() # 跳转到 Gihub 登录页面 await page.goto(\"https://github.com/login\") # 填入验证信息，type 是打字，fill 是复制粘贴 await page.get_by_label(\"Username or email address\").type(\"username\", delay=2000) await page.get_by_label(\"Password\").fill(\"password\") # 点击登录按钮 await page.get_by_role(\"button\", name=\"Sign in\").click() if __name__ == \"__main__\": asyncio.run(main()) 平时只需要 await page.pause() 然后在 record 模式下定位元素，开发效率极高。 动画使用 Screen To Gif 录制。 ","date":"2023-07-23","objectID":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:2:0","tags":["playwright"],"title":"playwright 快速上手指南","uri":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["playwright"],"content":"练习站点 https://sahitest.com/demo 想掌握 playwright 各种用法，建议用心过一遍。 ","date":"2023-07-23","objectID":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/:3:0","tags":["playwright"],"title":"playwright 快速上手指南","uri":"/posts/playwright-%E4%BA%94%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/"},{"categories":["工具"],"content":"理由 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:1:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"OneNote OneNote 的笔记是真正意义上的笔记，分页层级清晰，网页端的根据所选部分裁剪和全文裁剪功能更是一流。但是： 不支持 Markdown，而且微软官方也停止功能更新了。 一旦裁剪的内容多了不定时分类就会很乱，没有进知识体系（自身问题）。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:1:1","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"vscode 用 vscode 写博客文章也不顺手： 实时渲染（Live Preview）不理想。段落一长就要往右拖滚动栏。 每次打开 Markdown 文件要么自动打开另一侧的 Preview（简单修改文件又得手动关），要么每次都手动打开。 OneNote 双向同步略麻烦。 插件多了之后启动速度变慢。 所以尝试一下 Obsidian，看看能不能将平时的 信息收集 + 写作流 迁移过来。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:1:2","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"基础设置 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:2:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"语言 About -\u003e Language -\u003e 简体中文 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:2:1","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"字体 雾霭文楷 这字体是真好看。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:3:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"主题 Things ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:3:1","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"自用快捷键 默认的小窗预览文件好评，常用且实用。 CMD + 鼠标悬停链接 -\u003e 预览文件 Ctrl + E -\u003e 切换 编辑/预览 模式 Ctrl + O -\u003e 打开最近文件 Ctrl + Shift + F -\u003e 在所有文件内搜索内容 Ctrl + N -\u003e 新建文件 Ctrl + R -\u003e 文本内替换 Ctrl + T -\u003e 类似浏览器的新建页面 Ctrl + [1-9] -\u003e 切换标签页 Ctrl + Alt + = -\u003e 左右分屏 Ctrl + G -\u003e 关系图【不常用】 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:3:2","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"For Markdown Ctrl + Shift + I -\u003e 斜体 Ctrl + Shift + B -\u003e 加粗 Ctrl + Shift + N -\u003e 用模板新建文件 Ctrl + Shift + L -\u003e 添加超链接 Ctrl + Shift + K -\u003e 添加代办事项 Ctrl + ] -\u003e 缩进 Ctrl + [ -\u003e 取消缩进 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:3:3","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"段内换行 + 选中多个关键词 + 全选关键词 [[笔记软件迁移#Code Editor Shortcuts|额外的快捷键]] ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:3:4","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"引用 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:4:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"文件引用 写法：[[file]] 功能：引入文件。如果 file 不存在，会创建虚链接，Ctrl + 鼠标左键会自动创建文件。 示例：[[笔记软件迁移]] ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:4:1","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"节选引用 写法：[[file#title]] 功能：节选段落内容。 示例：[[笔记软件迁移#基础设置]] ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:4:2","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"别名引用 写法：![[file|shortname]] 功能：某个段落标题过长可以用别名替代。 示例：[[笔记软件迁移#常用快捷键]] -\u003e [[笔记软件迁移#常用快捷键|快捷键]] ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:4:3","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"块引用 写法：![[file^]] 功能：原地展开内容。 注意事项：不能套娃，不然会一直加载这部分的内容。 示例：![[笔记软件迁移#语言]] ![[笔记软件迁移#语言]] ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:4:4","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"嵌入引用 全内容 写法：![[file]] 功能：内嵌文章内容。 示例：![[你好]] ![[你好]] 部分内容 写法：![[file]] 功能：内嵌文章节选内容。 示例：![[你好#^d4edbb|only_print_hello]] ![[你好#^d4edbb|only_print_hello]] ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:4:5","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"模板 此前执行 hugo new posts/\u003cdir\u003e/\u003cnew_post.md\u003e 会在 dir 目录新建文章 new_post.md。 现在创建模板后新建文章文件也可以添加一样的文件头。新建模板目录 templates，然后写入以下内容： 模板日期格式改成 YYYY-MM-DDTHH:MM:SS+08:00 是为了 Github Actions 更新博客后返回正常的文章发布时间。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:5:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"插件 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:6:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"Code Editor Shortcuts 几个常用的快捷键在默认设置里面居然没有，安装 [Code Editor Shortcuts](obsidian-editor-shortcuts 替换。 段内换行（Ctrl + Enter） 段内向上换行（Ctrl + Shift + Enter） 同字母多选（Ctrl + D） 同字母全选（Ctrl + Alt + D） ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:6:1","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"Lacal REST API 裁剪网页笔记后保存到 obsidian。 PS. 我在没完全搞懂的情况下买了简阅高级会员，实在不理智。简阅这种功能繁复 + 文档混乱的页面我就应该第一时间右上角关闭的。还要所谓的高级会员功能体验如下： 使用网页剪辑功能要先进入阅读模式（快捷键 a a），还要确保 markdown 模板渲染不出问题。 然后再按下快捷键（o b）导出到 obsidian。 虽然一直开着 obsidian 也不算什么问题，但相比 OneNote 差的不是一星半点。 但目前唯一勉强能用的 obsidian-web插件遇到代码块渲染也有问题，后续再看看有没有更好的替代品。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:6:2","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"Natural Languagues Dates 方便在笔记内打出格式化的时间。 @time:now -\u003e 2023-07-22 03:28:22 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:6:3","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"Remotely Save 通过 OneNote 完成云同步。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:6:4","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"手机端 主要作用有两个： 看完 RSS 订阅后记录关键词和文章大体框架，后面再完善整篇文章。 记录当下想法或者发送手机截图发送到 obsidian 用于后续写作。 一方面，手机屏幕的阅读体验远不如电脑，没必要在手机上输入输出太多内容。 另一方面，博客文章图片使用图床但同时留有本地图片备份。 如果对整个文章仓库启用双向同步，那么对比文件一多，同步就慢 + 手机相册乱。 因此手机端设置双向同步的文件夹是临时文件夹，只用作记录想法和传手机截图用。但不知道为什么手机端的 Remotely Save 插件启动不了，转用 FolderSYnc 完成。 FolderSync 指定两边同步的目录。 点击右上方的心形按钮收藏临时目录方便后续从图库分享。 手机端添加一条笔记。 从手机图库分享图片到 FolderSync。 手机端设置快捷方式完成双向同步。 电脑端同步后， obsidian/Z_trans 文件夹已获取到相应更新，此时修改笔记。 手机端再次同步后能看到最新的修改内容。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:7:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"使用感受 实际使用下来，配合番茄钟的沉浸式写作体验非常好。如果只考虑纯文本写作： 甚至不用 Markdown 格式写作； 不怎么插入图片； 不考虑排版和生成流程图； 不去研究主题和 css 样式； 不去调整文字的大小和颜色； 不好奇各种插件的用法； obsidian 设置好快捷键就能用且好用，所以我个人很推崇 Gotify这类软件：do one thing，and do well。 ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:8:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"高级配置？ 工具配置只服务于实际需求，没有需求就不要创造需求。 唯有长期、稳定、高效的工作流程才值得我们花时间学习和配置，除非它哪天倒闭和变质了（ ","date":"2023-07-22","objectID":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/:9:0","tags":["obsidian","onenote","vscode","foldersync"],"title":"笔记软件迁移","uri":"/posts/%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E8%BF%81%E7%A7%BB/"},{"categories":["工具"],"content":"框架选择 QD 基于 HAR 的定时任务平台，上手简单。但是对于开发自由度来说不够高，也不好处理动态加载的页面。 青龙面板 相对友好的定时任务平台，自带依赖管理（Nodejs、Python、Linux），脚本类则支持 Python3、JavaScript、Shell、Typescript。 ","date":"2023-07-17","objectID":"/posts/checkin/:1:0","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["工具"],"content":"部署 # curl -sSL get.docker.com | sh docker run -dit \\ -v $PWD/ql/data:/ql/data \\ -p 5700:5700 \\ --name qinglong \\ --hostname qinglong \\ --restart unless-stopped \\ whyour/qinglong:debain 坑点： whyour/qinglong:latest 默认使用 alpine 精简镜像导致很多 python 依赖无法安装 因此选择 whyour/qinglong:debain 镜像。 ","date":"2023-07-17","objectID":"/posts/checkin/:2:0","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["工具"],"content":"签到脚本 本来是想用 requests 一把梭的，但是吾爱破解的签到页面用了动态加载 js ，直接访问接口会提示：请开启JavaScript并刷新该页。 想了解三者区别可以看这个：Playwright VS Selenium VS Puppeteer VS Cypress。 当时想着尝试新东西选了 playwright，体验很好，不再需要折腾各种新旧版本的 webdriver。 然后如无意外的出意外了。 ","date":"2023-07-17","objectID":"/posts/checkin/:3:0","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["工具"],"content":"playwright 如果快速上手可以看这一篇：[[Task/Playwright 五分钟上手指南/playwright 五分钟上手指南]] 官方文档很详细，API 设计很好（语法符合操作直觉），下面是通用的签到流程代码。 # coding:utf-8 import sys import asyncio from os.path import abspath, dirname, join from loguru import logger from playwright.async_api import async_playwright from playwright_stealth import stealth_async DIR_PATH = dirname(abspath(__file__)) PROXY = \"http://localhost:7890\" # log logger.add(f\"{join(DIR_PATH, 'log/v2ex.log')}\", format=\"{time} {level} {message}\") # conf title = \"V2EX\" cookie_file = join(DIR_PATH, \"cookie/v2ex.json\") url = \"https://v2ex.com\" sign_url = \"https://v2ex.com/mission/daily\" # gotify def push_msg(title, message): url = f\"{gotify_host}/message?token={gotify_token}\" data = {\"title\": title, \"message\": message, \"priority\": 7} resp = requests.post(url, json=data) async def sign(playwright): chromium = playwright.chromium browser = await chromium.launch(headless=False, proxy=PROXY) context = await browser.new_context( ignore_https_errors=True, user_agent=\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\", ) # 从文件读取 Cookie context = await browser.new_context(storage_state=cookie_file) page = await context.new_page() # 隐藏 webdriver 特征 await stealth_async(page) # 判断登录状态 # v2ex 需要先访问首页才能带 referer，不然无法签到。参考：https://www.v2ex.com/t/846469 await page.goto(url) if await page.get_by_text(\"记事本\").focus(): logger.error(签到成功) else: msg = \"Cookie 过期\" logger.error(msg) # 签到 await page.goto(sign_url) if sign_button := await page.get_by_text(\"领取 X 铜币\").first sign_button.click() msg = \"领取铜币成功\" logger.info(msg) else: msg = \"今日铜币已领取\" logger.info(msg) # 推送消息 push_msg(title, msg) # 退出 await browser.close() async def main(): async with async_playwright() as playwright: await sign(playwright) if __name__ == \"__main__\": asyncio.run(main()) 那么这么方便好用的代价是什么呢？ ","date":"2023-07-17","objectID":"/posts/checkin/:4:0","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["工具"],"content":"webdriver 检测 原生框架过不了 webdriver 检测。 解决办法：使用 playwright-stealth 绕过。 page = await context.new_page() # 新页面 # 隐藏 webdriver 特征 await stealth_async(page) 而 Selenium 什么设置都不需要就能绕过，更多常用参数可以看这个 init_selenium_driver.py。 from selenium import webdriver driver = webdriver.Chrome() driver.get(\"https://bot.sannysoft.com/\") driver.close() ","date":"2023-07-17","objectID":"/posts/checkin/:4:1","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["工具"],"content":"alpine 精简镜像的问题 根据 青龙无法安装python3的pycryptodome依赖 的说法，青龙平台使用 apline 镜像精简了很多东西，虽然体积小，但有很多依赖是需要进行编译安装的。而 alpine 本身的 C 实现是和 debian 这类系统是有区别的，导致即使库安装上了，却依然用不了 容器内部安装 playwright 失败。 而容器外部能正常安装。 即便 ddddocr 能在容器外部搭建 API 服务器解决，但要改仓库里面的镜像还有一大堆引用实现 playwright 实在不优雅，寄了。 吗？ Update At 2023-07-18 ","date":"2023-07-17","objectID":"/posts/checkin/:4:2","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["工具"],"content":"whyour/qinglong:debian 仓库作者最新回复：可以使用 whyour/qinglong:debian 镜像。 经测试容器内能安装上 playwright，但是树莓派 3B+ 孱弱的性能实在无法支持从容器内部执行 playwright。 而容器外部的原生环境执行一次签到需要一分钟多点（PC 平台5秒左右），所以在容器外部通过 apscheduler 错开一分钟实现定时签到。 又是白忙活的一天。 ","date":"2023-07-17","objectID":"/posts/checkin/:5:0","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["工具"],"content":"[不推荐]playwright Websocket Server 一开始是想看看有没有人在 alpine 内部安装 playwright 的，然后搜到 playwright_on_alpine_linux： 官方提供了相应 Dockerfile，只要安装 [playwright-python-remote](https://github.com/YusukeIwaki/playwright-python-remote 用 websocket 连接即可调用远程 playwright server。 pip install git+https://github.com/YusukeIwaki/playwright-python-remote from playwright_remote.sync_api import sync_playwright_remote with sync_playwright_remote('ws://127.0.0.1:8080/ws') as playwright: with playwright.chromium.launch() as browser: page = browser.new_page() page.goto('https://github.com/YusukeIwaki') page.screenshot(path='YusukeIwaki.png') 已在 Issue 评论区补充了实现方法，经测试，能从容器内部调用外部的 playwright ws 连接，但效率感人。 ","date":"2023-07-17","objectID":"/posts/checkin/:6:0","tags":["青龙面板","树莓派","playwright"],"title":"在树莓派部署青龙签到平台","uri":"/posts/checkin/"},{"categories":["onedrive"],"content":"简单记录搭建 onedrive-vercel-index 的过程。 官方文档的搭建流程清晰明了，跟着步骤来就行，唯一问题是官方仓库的 clientID 过期。 参考使用你自己的 client id 与 secret 修改自己 fork 的仓库下 api.config.js module.exports = { // The clientId and clientSecret are used to authenticate the user with Microsoft Graph API using OAuth. You would // not need to change anything here if you can authenticate with your personal Microsoft account with OneDrive International. clientId: 'd87bcc39-1750-4ca0-ad54-f8d0efbb2735', obfuscatedClientSecret: 'U2FsdGVkX1830zo3/pFDqaBCVBb37iLw3WnBDWGF9GIB2f4apzv0roemp8Y+iIxI3Ih5ecyukqELQEGzZlYiWg==', ... } 最后在 vercel dashboard 再设置下自定义域名，完美。 因为仓库用的是 LocalStorage 的方式，所以 .password 这种方法的不能完全保证安全性，感觉使用 github 的 env 变量这类方法更合适。 作者早期的 onedrive-cf-index 套用了 cloudflare，理论上在现有仓库手动反代一下效果更好。但挂载流媒体行为会违反 cf 的 tos，所以还是不折腾了。 各路人士薅了这么久 cf 羊毛，cf 还是财大气粗的提供各种优质服务，respct。 最后放效果图 不挂梯子的直链速度还可以，播放视频绰绰有余了 ","date":"2023-06-27","objectID":"/posts/oneindex/:0:0","tags":["oneindex","onedrive"],"title":"搭建一个属于自己的在线网盘","uri":"/posts/oneindex/"},{"categories":["杂谈","onedrive"],"content":"起因 本人一直对国内云盘一直没什么好态度。尤其是打开某盘，起手就默认勾选文件夹只等你一不小心按下同意按钮，直接自动扫盘（可能打开 APP 的时候就扫了）兼备份，更不说随处可见的推广和弹窗广告。 因此在涉及到有个人隐私（家庭照片）备份方案方面都是重要隐私先加密文件夹再丢上 OneDrive 保险库，不重要但设计隐私的文件直接丢进保险库。定期用 FreeFileSync 进行双向同步，移动硬盘针对全盘备份则是半年一次。 一切仿佛都是这么美好，甚至在发现一加云服务自动上传了我整个手机相册之后写了批量脚本全删掉了（为什么要手贱）。 ","date":"2023-06-26","objectID":"/posts/missing_photo/:1:0","tags":["onedrive"],"title":"因为云同步，我丢失了大学四年的照片","uri":"/posts/missing_photo/"},{"categories":["杂谈","onedrive"],"content":"出事 OneDrive 保险库一直都挺好用的，直到文件过多（什么文件我不说）后，Windows 端的云备份频繁卡死。不管是重置程序还是转移文件出保险库，只要保险库内文件数量到一定程度，OneDrive 扫盘建索引传文件这一套下来，不是卡在正在上传就是打开本地文件夹后云备份程序直接崩溃。 按理说转移出来创建两个文件夹分别加密就好了，但是懒（手贱还懒），转移出来我关掉保险库功能，结果增量同步后出现重复文件的问题。 ","date":"2023-06-26","objectID":"/posts/missing_photo/:2:0","tags":["onedrive"],"title":"因为云同步，我丢失了大学四年的照片","uri":"/posts/missing_photo/"},{"categories":["杂谈","onedrive"],"content":"云同步 != 云备份 可以留意到上一节我用的都是云备份，真正的云同步是某盘和一加自带的云服务这种，因此为了解决双向同步问题引入了 FreeFileSync。 整个双向云同步的逻辑就变成这样： 手机新增图片 手机开启 FTP 服务器 FreeFileSync 增量同步手机多个相册到 OneDrive 指定目录 Windows 本地 OneDrive 自动同步 手机端的 OneDrive 也自动同步 看上去都没什么问题，但是手机端的 OneDrive 会作妖。它会像下面这样提示你是否备份新出现的文件夹，然而实际上我已经把所有需要同步的相册目录添加进去了。 但是！手机新增的图片不仅会添加到你设定的文件夹去，还会被多一份拷贝添加到它固定（删了会自动创建）目录下：本机照片。 这就导致我每次同步都得从本机照片里找到需要或不需要的照片，根据不同目录（微信、淘宝、Bilibili、QQ、系统截图）手动筛一遍。 那手机 OneDrive 本地监听的备份目录意义何在？ 而且一旦手机端 OneDrive 先同步再走双向云同步流程的话，FreeFileSync 就分不清你想要的还是你想要删掉的，毕竟哪边修改日期更新就增量同步过去。 于是乎在 一加云相册被脚本删完 FreeFileSync 双向同步删掉 2020 年 2 月前所有照片 移动硬盘备份也是最新的（丢失输出的新增备份） 的叠加状态下，我成功丢失了大学四年所有照片，以及数十张更旧照片的所有回忆。 ","date":"2023-06-26","objectID":"/posts/missing_photo/:3:0","tags":["onedrive"],"title":"因为云同步，我丢失了大学四年的照片","uri":"/posts/missing_photo/"},{"categories":["杂谈","onedrive"],"content":"反思 现在去掉了整个双向同步流程，OneDrive 作为云备份，一加云服务则是云同步，移动硬盘备份前再三确认相册有无过多删减。 其实大学四年能回忆起来的东西并不多，大四拍毕业照当天我也和宿友感慨过： 大学四年，匆匆走过，形同路人。 谈不上多遗憾只是觉得时间走得太快，徒留少数自我感动的时刻和即将远走各方的失落。 大一到大四每个学期印象比较深的事件大概很久都不会忘记，但是以后就说不准了。更旧的照片也没有什么隐私，美食方面占了很大一部分，所以丢了也不遗憾。 我以前也不喜欢将个人隐私暴露到网络上，高中还把小学时期 QQ 空间的内容全删了。现在看来大可不必，相片存在的意义就是记录当下，对于个人而言就是定格时光和回忆的载体，不管多么幼稚可笑，都是难得的回忆。 隐私保护是必要的，记录当下更是。 ","date":"2023-06-26","objectID":"/posts/missing_photo/:4:0","tags":["onedrive"],"title":"因为云同步，我丢失了大学四年的照片","uri":"/posts/missing_photo/"},{"categories":["配置"],"content":"某天五黑大乱斗突然有小伙伴说我的耳机有电流沙沙声，插上耳机调大音量确实有底噪。 虽然他们说不太影响，但还是要解决。 打开声音属性 关闭麦克风加强 打开回声消除和噪声抑制 再次调大麦克风音量也没有底噪了，问题解决。 ","date":"2023-05-28","objectID":"/posts/%E8%80%B3%E6%9C%BA%E9%BA%A6%E6%B6%88%E9%99%A4%E5%BA%95%E5%99%AA%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["耳机","底噪"],"title":"耳机麦消除底噪的方法","uri":"/posts/%E8%80%B3%E6%9C%BA%E9%BA%A6%E6%B6%88%E9%99%A4%E5%BA%95%E5%99%AA%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["vits"],"content":"上回说到，在 huggingface 搭建好 vits server 后，平时直播的弹幕语音靠 bilive_dm 播报，有时候口糊听不清还要切窗口看一眼。然后看到弹幕姬有个自定义 tts 引擎，故考虑接入试试。 ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:0:0","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"Re: TTSCat Re: TTSCat 插件 以及 仓库地址 开幕 archived 问题不大。 插件页面有自定义 tts 引擎 url 的参考格式，怎么简单怎么来（GET）。 在临时目录添加一个 mp3 文件并启动 http 服务器 python3 -m http.server # 自定义引擎地址填入如下 url https://127.0.0.1:8000?text=$TTSTEXT 语音成功播放后感觉 so easy，然后如无意外的出现意外了。 ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:1:0","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"踩坑 fastapi 写个简单 get 接口。 @app.get(\"/voice\") async def get_audio(token: str, text: str): if token != os.environ.get(\"token\"): return {\"code\": 401} # vits 合成语音，返回二进制文件 audio = load_fast_vits(text) if audio is None: return {\"code\": 500} else: return FileResponse(audio) 发送弹幕后什么都没有发生，打开调试模式看看怎么回事。 一切正常，还是什么都没有发生。 在缓存目录下找到 get 获取到的音频文件，直接播放没有问题。 ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:2:0","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"坑1 切换到 dotNet 引擎，找到缓存下的文件，然后用回 python http 服务器测试，无声音。 切换到 百度 引擎得到音频文件后测试正常播放，迷惑。 ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:2:1","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"坑2 已知 vits 语音合成使用了 scipy 库，默认生成的是 wav 格式的音频。感觉是格式问题，然后就犯了个错误：图省事直接用 scipy.io.write 方法生成 mp3 文件。 结果无法播放，调试选项依旧不报错。 ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:2:2","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"Google Search 即便是谷歌搜索，在遇到冷门问题时也不一定有替代方案，不过万幸还是找到一个：MsTtsForBiliLiveDm。 仓库 archived 是因为微软关停了免费的网页 tts 服务（被短视频合成语音薅怕了估计）。 项目原理是通过微软免费的网页 tts 下载对应音频后接入弹幕姬。但是这更疑惑了，都是生成的 mp3 格式，为什么 vits 后端生成的音频就播放不了呢？ 还是直接联系一下作者吧，熟练的 git clone、git log，然后： commit 01cd771f3a7187746849f81632a74b56c5470ed6 (HEAD -\u003e master, origin/master, origin/HEAD) Author: Youmiel \u003c70473080+Youmiel@users.noreply.github.com\u003e Date: Thu May 11 14:57:29 2023 +0800 Archive repository. 这倒是提醒我也该设置邮箱隐私保护了，继续谷歌。 要是作者不用相同 ID，这篇文章就出不来了（ 私信后问题解决了，得用原生 mp3 格式。所以坑2偷懒直接生成 mp3 是不行的，得 wav 转 mp3。 后面又翻了下 NAudio Wiki，是支持 wav 和 mp3 的。 Re-TTS CAT 的实现看上去也没问题，大概是 bug 吧。 ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:3:0","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"wav to mp3 ffmpeg yes！ import subprocess subprocess.run( cmd=\"ffmpeg.exe -i test.wav test.mp3\", shell=True ) ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:4:0","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"坑3 本地测试正常了，DockerFile 加个 ffmpeg 的依赖，代码一加直接往 huggingface 推送，然后报了 Permission Denied 错误。 File \"/usr/local/lib/python3.9/os.py\", line 225, in makedirs mkdir(name, mode) PermissionError: [Errno 13] Permission denied: 'flagged' 一开始直接 chmod 777 /ttscache 还是会报错，然后官方文档建议新增一个用户并挂载目录，这样就没有读写权限问题了。 ffmpeg 正常转码输出 mp3 文件 ","date":"2023-05-23","objectID":"/posts/tts_for_danmuji/:5:0","tags":["Python","danmuji","tts","vits","huggingface","bilive_dm"],"title":"为弹幕姬 ReTTS-Cat 插件搭建自定义 tts 引擎","uri":"/posts/tts_for_danmuji/"},{"categories":["vits"],"content":"配置不难就是坑多，而且完全不可用。 ","date":"2023-03-18","objectID":"/posts/android_vits/:0:0","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"PRoot 与 chroot chroot 和 PRoot的一个主要区别是 chroot 是原生的。 PRoot通过使用 ptrace() 劫持系统调用参数和返回值来伪造文件系统布局和用户/组ID。 chroot不造成额外的开销，在任何设备上都不会出现问题，但是它需要root权限。 所以基于PRoot的 UserLAnd 和 Termux 并不适合。 一开始用 UserLAnd 配置环境倒是没问题，但是执行到 pip install package 的时候就报 Permission Denied 错误。 ","date":"2023-03-18","objectID":"/posts/android_vits/:1:0","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"root 闲置机器是 Nubia Z9，安卓 5.2 版本直接线刷回出厂版本后使用 Kingroot 一键 root。 不得不说这块屏幕和金属边框设计放到 2023 年还是很漂亮，最近新出的 Z50 Ultra 也是类似设计。 可惜的是 骁龙810 + 电池 2900毫安 + 3G 运行内存。810 在日常室温使用只能用烫手来形容，加上扎实的手感，拿起来怕摔加保护壳又没手感+升温，当日常备用机完全不合适。 ","date":"2023-03-18","objectID":"/posts/android_vits/:2:0","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"LinuxDeploy 仓库地址：LinuxDeploy 基本按图里面的配置或者全程科学上网都没有什么问题，BusyBox 实测是不需要的。 架构选 ARM64 即可，系统一定要选 LTS Release，非 LTS 不支持 deadsnakes 源，apt get install python3.7 肯定比源码编译快多了。当然，想尝试花一个小时从源码编译 Python3.7 我也不拦着（ ","date":"2023-03-18","objectID":"/posts/android_vits/:3:0","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"坑1：系统版本 Ubuntu 16.04.7 LTS (Xenial Xerus) 默认 Python3.5 安装 pytorch 会报错。 Ubuntu 22.04.2 LTS (Jammy Jellyfish) 的 Python3.10 则有依赖问题。 ","date":"2023-03-18","objectID":"/posts/android_vits/:3:1","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"坑2：extract/ssh start failed 一开始想自动分配空间，安装类型选了目录而不是镜像文件。 全程科学上网或换国内源安装均会报错，开 debug 提示 /bin/su no such file or directory。 没找到好的解决方法，如果可以目录安装还是建议用目录，镜像分配空间不管大小都不是很合适。 ","date":"2023-03-18","objectID":"/posts/android_vits/:3:2","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"坑3：默认分配的镜像大小是 2G 你可以想象一下编译了一个小时的 Python3.7 + 安装依赖不报错的情况下，突然提示空间分配不足且找不到扩容方法的心情吗。 ","date":"2023-03-18","objectID":"/posts/android_vits/:3:3","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"部署 基本按照图里的设置就能成功部署起来了，填写国内镜像源，勾选 SSH 服务，挂载点、声音、图形都不需要。 从 dash 切换到 bash 启动成功之后 SSH 连进去即可。 运行下面代码 选 no 重新进终端即可。 sudo dpkg-reconfigure dash # 更换国内源 sudo cp /etc/apt/source.list /etc/apt/source.list_bak vim /etc/apt/source.list deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse # 基础软件 sudo apt update sudo apt install wget curl vim git screen build-essential 安装 Python3.7 \u0026 pip No module named 'distutils.util 报错是因为没安装 python3.7-distutils。 error: command ‘/usr/bin/aarch64-linux-gnu-gcc’ failed with exit code 1 报错是因为没安装 python3.7-dev。 # !deadsnakes is only for ubuntu LTS releases! sudo apt-get install software-properties-common sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get install python3.7 python3.7-distutils python3.7-dev curl https://bootstrap.pypa.io/get-pip.py | python3.7 坑4：不要使用国内 pip 源 安装 pyopenjtalk 和其他依赖会报 403 错误。 配置虚拟环境 /home/pi/.local/bin/pip3.7 install virtualenv python3.7 -m virtualenv venv source venv/bin/activate vits 提供局域网内一个 Clash 的代理，如果直连 pypi 官方源速度很快则不需要。 export http_proxy=\"http://192.168.1.162:7890\" export https_proxy=\"http://192.168.1.162:7890\" 修改 requirements.txt，三个 torch 后面的 –extra-index-url 都去掉（使用 CPU 推理）。 只做推理不需要demucs、openai-whisper、gradio，再加上 fastapi、uvicorn、loguru。 git clone https://ghproxy.com/https://github.com/Plachtaa/VITS-fast-fine-tuning pip install -r requirements.txt api.py 和 server.py 参考 vits-mandarin-windows 即可。 只能说这个推理速度完全不意外，又是折腾没结果的一天。 ","date":"2023-03-18","objectID":"/posts/android_vits/:3:4","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["vits"],"content":"2023 年两台手机用蓝牙传图有种时代落幕感 ","date":"2023-03-18","objectID":"/posts/android_vits/:4:0","tags":["vits","ai语音合成","UserLAnd","Termux","Nubia Z9","LinuxDeploy","pyopenjtalk"],"title":"使用安卓设备运行 vits 语音合成","uri":"/posts/android_vits/"},{"categories":["Python"],"content":"Win10 下复制图片发送到 QQ 群总是变成文件，每次要打开图片-复制-关闭图片也很繁琐。 市面上现有的工具不多： xclip，仅限 Linux 平台使用。 CopyContents，免费试用 15 天，每次右键复制图片内容都提示一次，还有个巨复古的浮框。 ","date":"2023-02-08","objectID":"/posts/copyimagetoclipboard/:0:0","tags":["Python","win32clipboard"],"title":"CopyImageToClipboard","uri":"/posts/copyimagetoclipboard/"},{"categories":["Python"],"content":"Talk Is Cheap 保存为 pyw 文件用 pythonw.exe 执行避免出现一闪而过的黑框。 # coding:utf-8 import sys import traceback import win32clipboard from io import BytesIO from PIL import Image def send_to_clipboard(clip_type, data): win32clipboard.OpenClipboard() win32clipboard.EmptyClipboard() win32clipboard.SetClipboardData(clip_type, data) win32clipboard.CloseClipboard() def copy_image_to_clipboard(args): image = Image.open(args) output = BytesIO() image.convert(\"RGB\").save(output, \"BMP\") data = output.getvalue()[14:] output.close() send_to_clipboard(win32clipboard.CF_DIB, data) if __name__ == \"__main__\": try: copy_image_to_clipboard(sys.argv[1]) except Exception: traceback.print_exc() ","date":"2023-02-08","objectID":"/posts/copyimagetoclipboard/:1:0","tags":["Python","win32clipboard"],"title":"CopyImageToClipboard","uri":"/posts/copyimagetoclipboard/"},{"categories":["Python"],"content":"注册表 简单功能不用特意找 winreg 标准库写一大堆东西，参考 如何使用 .reg 文件添加、修改或删除注册表子项和值 ","date":"2023-02-08","objectID":"/posts/copyimagetoclipboard/:2:0","tags":["Python","win32clipboard"],"title":"CopyImageToClipboard","uri":"/posts/copyimagetoclipboard/"},{"categories":["Python"],"content":"添加 只关联了 JPG 和 PNG 格式 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\SystemFileAssociations\\.png\\Shell\\CopyImage] @=\"CopyImage\" [HKEY_CLASSES_ROOT\\SystemFileAssociations\\.png\\Shell\\CopyImage\\command] @=\"\u003cYour Python Path\u003e\\\\pythonw.exe \u003cYour Scipt Path\u003e.pyw %1\" [HKEY_CLASSES_ROOT\\SystemFileAssociations\\.jpg\\Shell\\CopyImage] @=\"CopyImage\" [HKEY_CLASSES_ROOT\\SystemFileAssociations\\.jpg\\Shell\\CopyImage\\command] @=\"\u003cYour Python Path\u003e\\\\pythonw.exe \u003cYour Scipt Path\u003e.pyw %1\" ","date":"2023-02-08","objectID":"/posts/copyimagetoclipboard/:2:1","tags":["Python","win32clipboard"],"title":"CopyImageToClipboard","uri":"/posts/copyimagetoclipboard/"},{"categories":["Python"],"content":"删除 在主菜单前加 - 即可 [-HKEY_CLASSES_ROOT\\SystemFileAssociations\\.png\\Shell\\CopyImage] [-HKEY_CLASSES_ROOT\\SystemFileAssociations\\.jpg\\Shell\\CopyImage] ","date":"2023-02-08","objectID":"/posts/copyimagetoclipboard/:2:2","tags":["Python","win32clipboard"],"title":"CopyImageToClipboard","uri":"/posts/copyimagetoclipboard/"},{"categories":["Python"],"content":"效果 ","date":"2023-02-08","objectID":"/posts/copyimagetoclipboard/:3:0","tags":["Python","win32clipboard"],"title":"CopyImageToClipboard","uri":"/posts/copyimagetoclipboard/"},{"categories":["Python"],"content":"References： pyperclip/issues/198 Windows下.py文件右键没有Edit with IDLE的解决办法 运行python程序不显示cmd的方法 ","date":"2023-02-08","objectID":"/posts/copyimagetoclipboard/:4:0","tags":["Python","win32clipboard"],"title":"CopyImageToClipboard","uri":"/posts/copyimagetoclipboard/"},{"categories":["杂谈"],"content":"人生意义也不过是去码头整点薯条。 ","date":"2022-08-23","objectID":"/posts/%E5%86%99%E4%BD%9C%E6%84%8F%E4%B9%89/:0:0","tags":null,"title":"写作意义","uri":"/posts/%E5%86%99%E4%BD%9C%E6%84%8F%E4%B9%89/"},{"categories":["杂谈"],"content":"别人说的 别人的文章写得很好，把你想说的全说了。 总是深思熟虑，文章也看似完美。 知识体系还是别人的，甚至模糊记忆的感受也是别人的。 时间一长什么都记不住。 ","date":"2022-08-23","objectID":"/posts/%E5%86%99%E4%BD%9C%E6%84%8F%E4%B9%89/:1:0","tags":null,"title":"写作意义","uri":"/posts/%E5%86%99%E4%BD%9C%E6%84%8F%E4%B9%89/"},{"categories":["杂谈"],"content":"我想说的 情感表达热烈，思路流程简洁。 团结紧张，严肃活泼。 博客有一个 当下迷思 的标签，仅有一篇文章，内容随时间段落更新一句话、一张图、一段思考过程。 可能很克制，可能很幼稚，可能很愤怒，可能很无厘头 也可能充满希望。 为了在某一天回想起来那些重要的，不重要的刹那，翻起万千思绪。 ","date":"2022-08-23","objectID":"/posts/%E5%86%99%E4%BD%9C%E6%84%8F%E4%B9%89/:2:0","tags":null,"title":"写作意义","uri":"/posts/%E5%86%99%E4%BD%9C%E6%84%8F%E4%B9%89/"},{"categories":["各种配置"],"content":"梯子爆炸 前几天经历过一次两个机场同时失效的情况，期间拿 Cloudflare WARP 客户端暂时顶过去。 梯子这东西日常使用感受不到好处，一旦所有梯子同时失效只能用灾难来形容。 虽然 Cloudflare 早几年被玩坏了，但是作为一个备用手段绰绰有余。 ","date":"2022-08-11","objectID":"/posts/warp/:1:0","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"APP 端 ZeroTrust 验证失败的绕过方法 在 Issue 区看到 AndroidStudio 抓包获取 Teams ID 的方法，尝试了一遍发现没什么必要：手动配置更快。 但手机端在验证的最后一步提示失败，挂梯子也无法解决。 在 Windows 留意到有一个 DOH 网关的字样。虽然 warp-cli set-gateway 是制定官方服务器作 DNS 查询，填到手机上却自动激活了 ZeroTrust。 ","date":"2022-08-11","objectID":"/posts/warp/:2:0","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"WRAP 配置 ZeroTrust 的教程一搜就有：滥用 Cloudflare ZeroTrust WARP 科学上网。 安装好 Cloudflare Windows Desktop Client 后开启本地代理，往 Clash 添加一个 Socks5 服务器即可。 ","date":"2022-08-11","objectID":"/posts/warp/:3:0","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"Clash mixed-port: 7890 # Linux 和 macOS 的 redir 代理端口 redir-port: 7892 # 允许局域网的连接 allow-lan: true # 规则模式：Rule（规则） / Global（全局代理）/ Direct（全局直连） mode: rule # 设置日志输出级别 (默认级别：silent，即不输出任何内容，以避免因日志内容过大而导致程序内存溢出）。 # 5 个级别：silent / info / warning / error / debug。级别越高日志输出量越大，越倾向于调试，若需要请自行开启。 log-level: info # Clash 的 RESTful API external-controller: '0.0.0.0:9090' # RESTful API 的口令 secret: '' dns: enable: true ipv6: true listen: '0.0.0.0:53' use-hosts: true enhanced-mode: fake-ip fake-ip-range: 198.18.0.1/16 nameserver: - https://doh.pub/dns-query - https://dns.alidns.com/dns-query fallback: - https://1.0.0.1/dns-query - https://45.11.45.11/dns-query fallback-filter: geoip: true ipcidr: - 240.0.0.0/4 proxies: - name: \"WARP+\" type: socks5 server: 127.0.0.1 port: 40000 proxy-groups: - name: \"手动选择节点\" type: select proxies: - \"WARP+\" rule-providers: reject: type: http behavior: domain url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt\" path: ./ruleset/reject.yaml interval: 86400 icloud: type: http behavior: domain url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt\" path: ./ruleset/icloud.yaml interval: 86400 apple: type: http behavior: domain url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt\" path: ./ruleset/apple.yaml interval: 86400 google: type: http behavior: domain url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt\" path: ./ruleset/google.yaml interval: 86400 proxy: type: http behavior: domain url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt\" path: ./ruleset/proxy.yaml interval: 86400 direct: type: http behavior: domain url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt\" path: ./ruleset/direct.yaml interval: 86400 private: type: http behavior: domain url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt\" path: ./ruleset/private.yaml interval: 86400 telegramcidr: type: http behavior: ipcidr url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt\" path: ./ruleset/telegramcidr.yaml interval: 86400 cncidr: type: http behavior: ipcidr url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt\" path: ./ruleset/cncidr.yaml interval: 86400 lancidr: type: http behavior: ipcidr url: \"https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt\" path: ./ruleset/lancidr.yaml interval: 86400 rules: # 这些是自定义规则，想要的可以继续加。 - DOMAIN-SUFFIX,cloudflareclient.com,DIRECT # 下面的规则是通过上面的rule-provider来确定的 - RULE-SET,private,DIRECT - RULE-SET,reject,REJECT - RULE-SET,icloud,DIRECT - RULE-SET,apple,DIRECT - RULE-SET,google,DIRECT - RULE-SET,proxy,WARP+ - RULE-SET,direct,DIRECT - RULE-SET,lancidr,DIRECT - RULE-SET,cncidr,DIRECT - RULE-SET,telegramcidr,WARP+ - GEOIP,,DIRECT - GEOIP,CN,DIRECT - MATCH,WARP+ ","date":"2022-08-11","objectID":"/posts/warp/:4:0","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"待解决的问题 ZeroTrust 能提供 50 设备同时在线且不限流量使用，WARP free 与 WARP+ 使用起来也无任何区别，但未来策略是否收紧不好说。 WARP Client 会根据最近的地理位置选择连接机房（SJC），有些机房（HKG）虽然能连上但是不稳定，甚至完全连不上。 WARP Linux Client 不支持 ARM 平台，树莓派要走 Wireguard。 ","date":"2022-08-11","objectID":"/posts/warp/:5:0","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"复制 23PB 流量 bug 什么年代了还在传统刷推荐流量，直接 generatewarpplusbot 生成一个用不完的 key，或者用以下复制 bug。 备份自己的 key 到 t.me/warpplus 拷贝一个 23PB 的 key 手机更换密钥后可用流量变成 23PB，再切换回自己的 key 会发现 23PB 流量已复制到自己账号下 ","date":"2022-08-11","objectID":"/posts/warp/:5:1","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"warp-cli 一开始搜切换warp机房得不到有效信息，后面找的 WARP-PLUS-HKG 也不好用。 后面在官方文档找到相关命令：set-custom-endpoint 这里我犯了一个错误，将 优选 IP 和 endpoint IP 弄混了。 warp-cli set-custom-endpoint 优选IP # 会报如下错误 Error: \"Failed to remove Trusted SSID because the SSID was invalid.\" 当时还疑惑优选IP:80|443 端口怎么连不上，后面在 Issue 才了解到 endpoint 域名是这个： endgate.cloudflareclient.com:2408 广州电信在 162.159.192.0 段直连完全连不上，换成 162.159.193.0 即可。 ","date":"2022-08-11","objectID":"/posts/warp/:5:2","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"wireproxy 顺着 fscarmen/warp 找到 wgcf，导出配置文件后修改 Endpoint 即可用 Wireguard 连上 WARP。 早期还有批处理改系统路由表分流后利用 Wireguard 科学上网的玩法，后面应对 UDP Qos 还套 fake-tcp，都太 Tricky 了。 直接替换相应 Endpoint。 [Interface] PrivateKey = Address = 172.16.0.2/32 Address = 2606:4700:110:8d72:9f99:8ebb:2ebe:8fb9/128 DNS = 1.1.1.1 [Peer] PublicKey = AllowedIPs = 0.0.0.0/0 AllowedIPs = ::/0 Endpoint = 162.159.193.1:2408 #engage.cloudflareclient.com:2408 在树莓派配置 warp-go.sh 失败后找到 wireproxy，开启本地代理仅需以下配置： [Interface] Address = 172.16.0.2/32 PrivateKey = DNS = 119.29.29.29,8.8.8.8,1.1.1.1,45.11.45.11 [Peer] PublicKey = Endpoint = 162.159.193.1:2408 PersistentKeepalive = 25 [Socks5] BindAddress = 127.0.0.1:40000 但是这种方法挂个后台+自启动也不优雅，将上面的 BindAddress 改为监听 0.0.0.0 即可用 Clash 串联树莓派，作为备用手段不要求速度和延迟。 Windows 端启动后隐藏窗口的批处理文件写法，只能在任务管理器找到 wireproxy.exe 进程。 @echo off if \"%1\"==\"h\" goto begin start mshta vbscript:createobject(\"wscript.shell\").run(\"\"\"%~nx0\"\" h\",0)(window.close)\u0026\u0026exit :begin taskkill /T /F /IM wireproxy.exe wireproxy.exe -c wireproxy.conf pause 只想 cmd 窗口最小化则可以这么写 @echo off taskkill /T /F /IM wireproxy.exe start /min wireproxy.exe -c wireproxy.conf ","date":"2022-08-11","objectID":"/posts/warp/:5:3","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["各种配置"],"content":"全自动优选 Endpoint 不考虑速度，只测试连通性后根据最低延迟优选 Endpoing，半小时跑一遍脚本 * */30 * * * /usr/bin/python /home/pi/best_endpiont.py 脚本看注释就能懂，工作普遍用第三方库（方便好用）导致写脚本的习惯不太好，以后尽量改成标准库。 #!/usr/bin/env python3 # -*- coding:utf-8 -*- import re import random import functools import subprocess from os.path import abspath, dirname, join from concurrent.futures import ThreadPoolExecutor, as_completed import requests from loguru import logger # 进程 Process 的创建远远大于线程 Thread 创建占用的资源 MAX_WORKERS = 10 LATENCY = {} NODES = [192, 193, 195] # 有些地区 192 段可能会被墙 REQUEST_TIMEOUT = 3 URL = \"https://1.1.1.1/cdn-cgi/trace\" IP_REG = r\"Endpoint = (.*?):2408\" BINDADDRESS_REG = r\"BindAddress = 0\\.0\\.0\\.0:\\d+\" DIR_DIR = abspath(dirname(__file__)) BASECONF = \"\"\" [Interface] PrivateKey = kPRKd3QemCiu3NRISPuxkYulex5Pvm91Yz+Sm5R5bFI= Address = 172.16.0.2/32 DNS = 1.1.1.1 MTU = 1380 [Peer] PublicKey = bmXOC+F1FxEMF9dyiK2H5/1SUtzH0JuVo51h2wPfgyo= AllowedIPs = 0.0.0.0/0 AllowedIPs = ::/0 Endpoint = 162.159.192.1:2408 [Socks5] BindAddress = 0.0.0.0:19000 \"\"\" def get_best_endpoint(mg_dict) -\u003e str: best_endpoint = sorted(mg_dict.items(), key=lambda x: x[1])[0] # asc return best_endpoint def generate_endpoint_configs() -\u003e list: \"\"\"以随机端口生成各个 IP 段的 wireproxy 配置信息\"\"\" endpoint_configs = [] for node in NODES: for i in range(1, 11): port = random.choice(range(10000, 20000)) socks_port = re.sub(BINDADDRESS_REG, f\"BindAddress = 0.0.0.0:{port}\", BASECONF) data = re.sub(r\"162\\.159\\.(.*?):2408\", f\"162.159.{node}.{i}:2408\", socks_port) endpoint_configs.append(data) # 生成文件 ip = re.findall(IP_REG, data)[0] with open(join(DIR_DIR, f\"config/{ip}.conf\"), \"w\") as f: f.write(data) return endpoint_configs def check_latency(config, mg_dict, mg_lock): \"\"\" 从生成的配置文件获取 IP 和 PORT IP 作为文件名生成多个配置文件，避免同一文件读写冲突 Port 作为对应代理端口 \"\"\" ip = re.findall(IP_REG, config)[0] port = re.findall(BINDADDRESS_REG, config)[0].split(\":\")[1] # [\"0.0.0.0\", 19000] dynamic_proxies = {\"http\": f\"socks5://127.0.0.1:{port}\", \"https\": f\"socks5://127.0.0.1:{port}\"} try: wireproxy = subprocess.Popen(args=[f\"/home/pi/bin/wireproxy -d -c {DIR_DIR}/config/{ip}.conf\"], shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE) ## stdout.read() 会阻塞 # logger.error(f\"os.getpid() -\u003e stdout:{wireproxy.stdout.read()}\") # logger.error(f\"os.getpid() -\u003e stderr:{wireproxy.stderr.read()}\") res = requests.get(url=URL, proxies=dynamic_proxies, timeout=REQUEST_TIMEOUT) if res.status_code == 200: logger.info(f\"ip: {ip}, elapsed: {res.elapsed.total_seconds()}\") with mg_lock: mg_dict[ip] = res.elapsed.total_seconds() except Exception as e: logger.error(f\"ip: {ip}, Exception: {str(e)}\") with mg_lock: mg_dict[ip] = 999 finally: wireproxy.kill() def rewrite_restart(best_endpoint): \"\"\"覆写本地配置文件再重启服务\"\"\" global BASECONF # wireproxy 配置默认 19000 端口，串联 Clash base = re.sub(r\"Port = \\d+\", f\"Port = 19000\", BASECONF) bind_address = re.sub(BINDADDRESS_REG, f\"BindAddress = 0.0.0.0:19000\", base) ip = best_endpoint[0] config = re.sub(r\"Endpoint = (.*?):2408\", f\"Endpoint = {ip}:2408\", bind_address) with open(\"/home/pi/config/wireproxy.conf\", \"w\") as f: f.write(config) subprocess.run(args=[\"sudo killall wireproxy\"], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) subprocess.run(args=[\"/home/pi/bin/wireproxy -d -c /home/pi/config/wireproxy.conf\"], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) if __name__ == \"__main__\": # windows 在头部引用会触发 spwan error，还需要 freeze_support() from multiprocessing import Manager # 多进程，大量子进程由 Pool 维护，少量子进程用 Process 比较灵活 # 多进程共享变量 mg_dict = Manager().dict() # {ip: latency, ip2: latency2...} mg_lock = Manager().Lock() # 多进程封装多变量 pt = functools.partial(check_latency, mg_dict=mg_dict, mg_lock=mg_lock) # 生成配置文件 endpoint_configs = generate_endpoint_configs() # 多线程池 with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor: executor.map(pt, endpoint_configs) # 输出结果 best_endpoint = get_best_endpoint(mg_dict) logger.add(f\"{DIR_DIR}/run.log\", format=\"{time} {level} {message}\") logger.debug(f\"best_endpoint: {best_endpoint}\") # 重启服务 rewrite_restart(be","date":"2022-08-11","objectID":"/posts/warp/:6:0","tags":["warp","zerotrust","wireguard","clash","raspberry"],"title":"WARP 作为科学上网备用手段","uri":"/posts/warp/"},{"categories":["树莓派"],"content":"你真的需要云服务器吗 大二买的 Raspberry Pi 3B+ 至今服役在家里的路由器旁，虽然我从未拿它做什么正儿八经的研究和生产，但是想要折腾新东西的时候总是先在上面跑。 想起前几年买的国内云学生机，食之无味弃之不可惜。一方面写写博客纯静态页面挂载在 GitHub 上足够，另一方面很多用得到的服务也不需要这么多性能。 ","date":"2022-01-29","objectID":"/posts/raspbot/:1:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"fail2Ban 仓库地址：fail2Ban 如果用的是 Python3，需要先执行一遍 ./fail2ban-2to3。不然会报如下错误： ERROR: No module named 'ConfigParser' ","date":"2022-01-29","objectID":"/posts/raspbot/:2:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"aliddns 仓库地址：aliddns 广州电信给了公网 IPV4 地址，路由器也开启了相应 ddns 以及端口映射。树莓派的 ddns 主要是解析 IPV6 地址，多点保险手段总是好的。 ","date":"2022-01-29","objectID":"/posts/raspbot/:3:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"UnblockNeteaseMusic 仓库地址：UnblockNeteaseMusic ","date":"2022-01-29","objectID":"/posts/raspbot/:4:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"Clash 仓库地址：Clash 自用机场和 WARP(wireproxy) 两套配置，后者反而还稳定些（低频率请求）。 ","date":"2022-01-29","objectID":"/posts/raspbot/:5:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"go-cqhttp 仓库地址：go-cqhttp 配合 nonebot 插件跑 qq 机器人，平时搜搜图还是很好用的。 ","date":"2022-01-29","objectID":"/posts/raspbot/:6:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"v2ray 仓库地址：V2ray 前两年折腾联通 host 免流：直接花三块钱买网上提供的云免流服务，直接把各种 host 保存下来。一不需要手机安装 PackageCapture 抓包，二不怕短期失效。 pull.free.video.10010.com shoutingtoutiao1.10010.com 现在公司和家里的 WiFi 覆盖时间已经完全不需要折腾了。工作之后对时间开销看得更重：能花钱解决的中长期（持续需求）问题一律花钱解决。 当然，国内网盘这种东西不值得我付费。 ","date":"2022-01-29","objectID":"/posts/raspbot/:7:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"OneDrive 之前也尝试过用全量备份脚本然后隔段时间就保存到电脑，但是压缩镜像耗时问题以及反复解压很容易忘记备份了什么。 现在干脆直接将本地目录（常用软件、各类配置文件）整个上传到 OneDrive，crontab 下加一行实现定时增量备份。 /home/pi/bin/rclone sync /home/pi/ rasp:/Raspberry --transfers 16 -P --onedrive-chunk-size 40M 用到的 Rclone 配置看这篇：Linux使用Rclone挂载OneDrive网盘 ","date":"2022-01-29","objectID":"/posts/raspbot/:8:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["树莓派"],"content":"telegrambot 文档地址：python-telegram-bot 在外有电脑远程连回树莓派是挺方便，但是只有手机的情况下敲命令还反复缩放界面看服务运行情况就不太优雅了。 官方给的接口很全，只要你愿意，用 Flask 接入都没问题。功能少还是直接写比较快。 参考 Warpplus #!/usr/bin/env python3 # -*- coding: utf-8 -*- import json import time import logging import subprocess from typing import Optional, Union from telegram import Update, error from telegram.ext import CallbackContext, CommandHandler, Updater logging.basicConfig( format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\", level=logging.INFO ) # Telegram bot API Token (可在 @botfather 获取) TOKEN = \"TOKEN_HERE\" # Telegram 用户 ID (在 @getidsbot 发送 /start 获取) USER_ID = \"USER_ID_HERE\" class RaspBot(object): def __init__(self, user_id: int): self._user_id = str(user_id) self._bot = None self._update = None self._message_id = None @staticmethod def is_who(update: Update, n: Optional[int] = 3) -\u003e tuple: chat_id = update.message.chat_id user_id = update.message.from_user.id username = update.message.from_user.username first_name = update.message.from_user.first_name name = username if username else first_name chat_type = update.message.chat.type if n == 6: return chat_id, user_id, username, first_name, name, chat_type return chat_id, user_id, name def send_command(update: Update, context: CallbackContext): chat_id, user_id, name = RaspBot.is_who(update) logging.info(f\"{name} ({user_id}) | 正在输入命令...\") if not context.args: # 无参数 result = \"no args input\" else: _args = context.args result = subprocess.run(\" \".join(_args), stderr=subprocess.PIPE, stdout=subprocess.PIPE, shell=True) logging.info(f\"command: {_args}\") logging.info(f\"returncode: {result.returncode}\") logging.info(f\"stderr: {result.stderr.decode('utf-8')}\") logging.info(f\"stdout: {result.stdout.decode('utf-8')}\") # telegram 信息最大长度为 4096 bytes if len(result.stdout) \u003e= 4096: result.stdout = result.stdout[:4096] context.bot.send_message( chat_id=chat_id, text=f\"returncode: {result.returncode}\\n\" +f\"stderr: {result.stderr.decode('utf-8')}\\n\" +f\"stdout: {result.stdout.decode('utf-8')}\\n\" ) def start(update: Update, context: CallbackContext): chat_id, user_id, name = RaspBot.is_who(update) logging.info(f\"[+] {name} ({user_id}) | 欢迎使用\") message_id = context.bot.send_message( chat_id=chat_id, text=f\"{name}，欢迎使用\\n\" + \"/start - 开始使用\\n\" + \"/c - 命令行\\n\", parse_mode=\"Markdown\" ).message_id del_msg(60, context, chat_id, message_id) def main(): updater = Updater(TOKEN, use_context=True, request_kwargs={\"proxy_url\": \"http://127.0.0.1:7890\"}) # Updater 设置代理 dp = updater.dispatcher dp.add_handler(CommandHandler(\"start\", start, run_async=True)) dp.add_handler(CommandHandler(\"c\", send_command, run_async=True)) updater.start_polling() updater.idle() if __name__ == \"__main__\": main() 还有一些签到类（b站直播间、v2ex）脚本就不提了，时效性一般。 ","date":"2022-01-29","objectID":"/posts/raspbot/:9:0","tags":["Raspberry","树莓派"],"title":"我在树莓派上跑了多少服务","uri":"/posts/raspbot/"},{"categories":["杂谈"],"content":"自建还是机场 遥想大一暑假，一个零基础小白捣鼓 Shadowsocks 花了整整三天： 找免费 VPN 注册搬瓦工 搜索 Linux 的各种命令行用法 配置编译环境一大堆报错 从 Ubuntu12.04 到 CentOS7 再到 CentOS6 重复 2-3 直到跑起 ss-server Chrome 搭配 SwitchyOmega 打开谷歌的一瞬间有莫大的成就感 在油管看完 Maroon5 - Payphone 的 MV 后开始思考翻墙有什么用 也曾陷入过追求工具的狂热 | 可用性 | 速度 | 开销 | | 付费 | 薅羊毛 | VPS | | SS | SSR | V2ray | Trojan | Xray | | CN2 | IPLC | IEPL | Anycast |中转-落地 | 每一项指标都在与 GFW 斗智斗勇，耗费大量时间精力就为了延迟和测速跑分能更好看一些。 可是我只是日常谷歌查查资料也没有什么大流量开销，秉持着能用就行的原则找了些口碑还行的小众机场，买不过期的流量包完全能满足需求。 还是那句：能用就行 ","date":"2022-01-21","objectID":"/posts/trollinggfw/:1:0","tags":["科学上网","杂谈"],"title":"当你的朋友需要科学上网的时候","uri":"/posts/trollinggfw/"},{"categories":["杂谈"],"content":"当亲戚朋友问你如何科学上网的时候 早期作为一个热心人士肯定是知无不言获得一致好评，到后面你都忘了有这回事的时候。 我连不上外网 | 还有新的梯子吗 | 怎么这个要钱啊。 后面我发现问题在我，稳定科学上网是不存在的。绝大部分问题发生的时候我都能靠搜索引擎解决，但是他们不会 他们只会关心能不能用，好不好用。 到现在我就直接说：“我也是找免费的用，不稳定还卡，不好意思”。 好心不办坏事，吃力不讨好罢了。 ","date":"2022-01-21","objectID":"/posts/trollinggfw/:2:0","tags":["科学上网","杂谈"],"title":"当你的朋友需要科学上网的时候","uri":"/posts/trollinggfw/"},{"categories":["Python"],"content":"目录结构 C:\\USERS\\EVILMASS\\DESKTOP\\PATH0 │ server.py ├───path1 │ │ func.py │ │ __init__.py └───path2 │ func.py │ __init__.py ├───path2_1 │ │ func.py │ │ __init__.py │ ├───path2_1_1 │ │ │ func.py │ │ │ special.py │ │ │ __init__.py ","date":"2021-02-21","objectID":"/posts/python_import/:1:0","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"__init__.py 一个 module1.py 文件可以看作一个模块：import module1 __init__.py 则是将一个文件夹变为 package 每一次 import 都会执行 __init__.py 内的代码。 # no __init__.py from path2.path2_1.func import echo from path2.path2_1.special import echo_special # has __init__.py from .func import * from .special import * from path2.path2_1 import echo, echo_special ","date":"2021-02-21","objectID":"/posts/python_import/:2:0","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"sys.path 实际遇到的绝大部分问题都是引用路径和循环引用问题，添加临时引用可以解决但请使用 绝对路径！ 绝对路径！ 绝对路径！ ","date":"2021-02-21","objectID":"/posts/python_import/:3:0","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"临时引用 针对不频繁调用的模块可以在入口处添加临时引用 import sys from os.path import abspath, join, dirname # 添加临时引用目录 sys.path.append(join(abspath(dirname(__file__)), \"path2/path2_1/path2_1_1\")) from special import echo_special echo_special() \u003e\u003e\u003e echo_special from: C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1 ","date":"2021-02-21","objectID":"/posts/python_import/:3:1","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"路径引用问题 path0\\path2\\path2_1\\path2_1_1\\special.py 调用同级 text 文件夹下的 echo 模块 # path0\\path2\\path2_1\\path2_1_1\\__init__.py from .func * # path0\\path2\\path2_1\\path2_1_1\\special.py\\text\\__init__.py from .func * # path0\\path2\\path2_1\\path2_1_1\\special.py import func from func import echo as local_echo import text from text.func import echo as text_echo def echo_special(): func.echo() local_echo() text.echo() text_echo() if __name__ == \"__main__\": echo_special() # path0\\server.py 导入 echo_special 会报错，即便有 text.__init__.py from path2.path2_1.path2_1_1.special import echo_special echo_special() Traceback (most recent call last): File \"server.py\", line 27, in \u003cmodule\u003e from path2.path2_1.path2_1_1.special import echo_special File \"C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1\\__init__.py\", line 2, in \u003cmodule\u003e from .special import * File \"C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1\\special.py\", line 5, in \u003cmodule\u003e from text.func import echo as text_echo ModuleNotFoundError: No module named 'text' 但直接在 path2_1_1 目录下执行 python special.py 是正常运行的。 cd C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1 python special.py \u003e\u003e\u003e echo from: C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1 \u003e\u003e\u003e echo from: C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1 \u003e\u003e\u003e echo from: C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1\\text \u003e\u003e\u003e echo from: C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1\\text ","date":"2021-02-21","objectID":"/posts/python_import/:3:2","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"错误示范 # 多了一个 `.` 能让 `server.py` 跑起来 from .text.func import echo as text_echo # 但在 path2_1_1 目录下运行则会报错 cd C:\\Users\\Evilmass\\Desktop\\path0\\path2\\path2_1\\path2_1_1 python special.py \u003e\u003e\u003e Traceback (most recent call last): \u003e\u003e\u003e File \"special.py\", line 5, in \u003cmodule\u003e \u003e\u003e\u003e from .text.func import echo as text_echo \u003e\u003e\u003e ImportError: attempted relative import with no known parent package ","date":"2021-02-21","objectID":"/posts/python_import/:3:3","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"sys.path 绝大部分问题只要检查一下 sys.path 就能解决 import sys print(sys.path) \u003e\u003e\u003e['C:\\\\Users\\\\Evilmass\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\DLLs', 'C:\\\\Users\\\\Evilmass\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib', 'C:\\\\Users\\\\Evilmass\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37', 'C:\\\\Users\\\\Evilmass\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages'] 很明显没有 text 目录，那么 server.py 加临时引用试试。 import sys from os.path import abspath, join, dirname # 添加临时引用目录 sys.path.append(join(abspath(dirname(__file__)), \"path2/path2_1/path2_1_1/text\")) from path2.path2_1.path2_1_1.special import echo_special echo_special() \u003e\u003e\u003e 问题解决。 ","date":"2021-02-21","objectID":"/posts/python_import/:4:0","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"if name == “main” 如果作为脚本直接运行，会执行 __name__ == \"__main__\" 下面的内容 如果是被其他 py 文件作为 package 引用则不执行 99% 的文章都会这么告诉你，少部分提一下 ___name__ 作用域，我的建议是： Talk Is Cheap, Show Me Code # echo.py def echo(): print(__name__) if __name__ == \"__main__\": echo() print(\"after echo, run this\") \u003e\u003e\u003e \"__main__\" \u003e\u003e\u003e \"after echo, run this\" # another.py from echo import echo print(echo.__name__) \u003e\u003e\u003e \"echo\" ","date":"2021-02-21","objectID":"/posts/python_import/:5:0","tags":["Python"],"title":"python import","uri":"/posts/python_import/"},{"categories":["Python"],"content":"中国有句古话：好记性不如烂笔头。看会了和学会了是两码事，能教会别人说明是真掌握了。 比起一堆 job1 | job2 和 生产者-消费者 模型，单纯复制粘贴相似度 99% 的代码就算自己敲一遍也不会有印象。 ","date":"2021-02-11","objectID":"/posts/multithreading/:0:0","tags":["Python","多线程","multitreading"],"title":"Python 多线程笔记","uri":"/posts/multithreading/"},{"categories":["Python"],"content":"反向思考 ","date":"2021-02-11","objectID":"/posts/multithreading/:1:0","tags":["Python","多线程","multitreading"],"title":"Python 多线程笔记","uri":"/posts/multithreading/"},{"categories":["Python"],"content":"请写出一个死锁的案例 加锁即为互斥，防止多线程同时修改同一个资源导致数据错误。 A 拿酱油 -\u003e 酱油炒饭耗时10分钟 -\u003e 拿盐 # 等待B放回盐 -\u003e 盐水菜心耗时5分钟 -\u003e 放回盐 -\u003e 放回酱油 B 拿盐 -\u003e 盐水菜心耗时5分钟 -\u003e 拿酱油 # 等待A放回酱油 -\u003e 酱油炒饭耗时10分钟 -\u003e 放回酱油 -\u003e 放回盐 你在等酱油我在盐，两人的下一道菜就永远卡这了。 当然这种写法肯定是有问题的，资源执行和释放的顺序不一致。 解决方法 让步： 只要每个线程执行完任务立马释放相应资源，线程崩溃的话设置好超时释放。 排队： 同时竞争资源，用队列（推荐）解决。 规则： 占用资源前给予规则限制。 例子：5人吃饭同时拿起左边筷子并等待右边筷子的释放。 解决：给筷子编号，没拿到小号筷子前不能拿大号的。最大数字的筷子不可能单独拿到，问题解决。 ","date":"2021-02-11","objectID":"/posts/multithreading/:1:1","tags":["Python","多线程","multitreading"],"title":"Python 多线程笔记","uri":"/posts/multithreading/"},{"categories":["Python"],"content":"如果用多进程处理多线程代码，会发生什么 问的其实是二者在使用方面的区别，首先自然是确定多线程代码执行的任务是什么。 如果要处理 `IO密集型`任务，用多进程反而会慢，主要耗时在创建和维护进程过程。 如果处理 `CPU密集型`任务，则可以充分利用多核优势并行计算。 多进程的主要问题： 进程不共享内存，计算的输入必须被传到每个工作进程里，比如列表中的元素； 能被传递的东西必须 picklable，而有相当多的东西是 unpicklable 的； 如果后续程序执行需要并行计算的输出，那么这些输出也得 picklable； Pickle -\u003e unpickle 操作带来了额外的性能开销。 多线程涉及资源竞争\u0026修改、死锁、上下文切换导致效率下降问题。 ","date":"2021-02-11","objectID":"/posts/multithreading/:1:2","tags":["Python","多线程","multitreading"],"title":"Python 多线程笔记","uri":"/posts/multithreading/"},{"categories":["Python"],"content":"什么时候加 .join() import time import threading def fun(second): time.sleep(second) print(f\"{threading.current_thread().name} -\u003e execute fun\") t1 = threading.Thread(target=fun, args=(5, )) t2 = threading.Thread(target=fun, args=(3, )) t1.start() t2.start() t1.join() t2.join() # 甚至这样 t1.start() t1.join() t2.start() t2.join() 很多人会这么写多线程代码，执行后会发现上面写法需要 5 秒多点没问题，但是下面的写法串行输出一共需要 5+3 秒，然后： 这是 GIL 导致的多线程效率问题，所以我们用多进程吧。 呃呃。 .join() 会卡住主线程，并让当前已经 .start() 的子线程继续运行，直到调用 .join() 的这个线程运行完毕才会继续运行主线程。 if __name__ == '__main__': print(\"这里是主线程\") t1 = Thread(target=task1) # t1.setDaemon(True) # 设置为守护进程，必须在start之前 t1.start() # 阻塞 t1.join() print(\"主线程结束了\") \u003e\u003e\u003e \"这里是主线程\" \"线程1执行完毕\" \"主线程结束了\" 就算给每个线程都加，耗时短的任务立刻返回结果让其他子线程继续执行，没有任何意义。 .join() 强调顺序执行，你只需要阻塞耗时最长的线程任务即可。 所以上述代码改成这样： t1.start() t2.start() t1.join() 为什么爬虫多个 url 返回前，每个线程都要加 .join()呢？因为每个线程在执行网络请求的时候，返回时间有差异，必须保证每个线程返回结果主线程才能调度后续任务。 thread_list = [] for _ in range(10): thread = threading.Thread(target=scrapy, args=(urls)) thread_list.append(thread) for thread in thread_list: thread.join() ","date":"2021-02-11","objectID":"/posts/multithreading/:1:3","tags":["Python","多线程","multitreading"],"title":"Python 多线程笔记","uri":"/posts/multithreading/"},{"categories":["Python"],"content":"什么时候加 .setDeamon(True) 守护：与主线程同生共死，这么理解就很直观了。 如果主线程永远不退出，设置守护线程无意义。 如果把子线程的代码写在 while True 里面一直循环，要设置为守护线程。不然主线程结束了，子线程还一直运行，程序结束不了。 ","date":"2021-02-11","objectID":"/posts/multithreading/:1:4","tags":["Python","多线程","multitreading"],"title":"Python 多线程笔记","uri":"/posts/multithreading/"},{"categories":["Python"],"content":"事件的使用场景 常规使用场景： 用户外部发送终止命令结束程序，彻底结束子线程。 等待数据库的连接信号就绪。 池与信号量是两个完全不同的概念 ，进程池Pool(4),最大只能产生4个进程，而且从头到尾都只是这四个进程，不会产生新的，而信号量是产生一堆线程/进程。 ","date":"2021-02-11","objectID":"/posts/multithreading/:1:5","tags":["Python","多线程","multitreading"],"title":"Python 多线程笔记","uri":"/posts/multithreading/"}]